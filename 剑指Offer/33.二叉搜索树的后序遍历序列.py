"""
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。

参考以下这颗二叉搜索树：

     5
    / \
   2   6
  / \
 1   3

示例 1：
输入: [1,6,3,2,5]
输出: false

示例 2：
输入: [1,3,2,6,5]
输出: true

解题思路：
后序遍历定义： [ 左子树 | 右子树 | 根节点 ] ，即遍历顺序为 “左、右、根” 。
二叉搜索树定义： 左子树中所有节点的值 < 根节点的值；右子树中所有节点的值 > 根节点的值；其左、右子树也分别为二叉搜索树。

递归分治
根据二叉搜索树的定义，可以通过递归，判断所有子树的 正确性 （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。
递归解析：
1.终止条件： 当i≥j，说明此子树节点数量≤1，无需判别正确性，因此直接返回true；
2.递推工作：
    1.划分左右子树： 遍历后序遍历的[i,j]区间元素，寻找第一个大于根节点的节点，索引记为m。此时，可划分出左子树区间[i,m−1]、右子树区间[m,j−1] 、根节点索引j 。
    2.判断是否为二叉搜索树：
        1.左子树区间[i,m−1]内的所有节点都应<postorder[j] 。而第 1.划分左右子树 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。
        2.右子树区间[m,j−1]内的所有节点都应>postorder[j] 。实现方式为遍历，当遇到≤postorder[j]的节点则跳出；则可通过p=j判断是否为二叉搜索树。
3.返回值： 所有子树都需正确才可判定正确，因此使用与逻辑符&&连接。
    1.p=j ：判断此树是否正确。
    2.recur(i,m−1) ：判断此树的左子树是否正确。
    3.recur(m,j−1) ：判断此树的右子树是否正确。

复杂度分析：

时间复杂度O(N^2)： 每次调用recur(i,j)减去一个根节点，因此递归占用O(N)；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用O(N)。
空间复杂度O(N)： 最差情况下（即当树退化为链表），递归深度将达到N。

"""


class Solution:
    def verifyPostorder(self, postorder):
        def recur(i, j):  # 后序遍历，j为根节点
            if i >= j:
                return True
            p = i
            while postorder[p] < postorder[j]:
                p += 1
            m = p  # 第一个大于根节点的值，划分左右子树区间
            while postorder[p] > postorder[j]:
                p += 1
            return p == j and recur(i, m - 1) and recur(m, j - 1)

        return recur(0, len(postorder) - 1)
