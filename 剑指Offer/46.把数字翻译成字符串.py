"""
给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

示例 1:
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"

动态规划解析：
记数字num第i位数字为xi，数字num的位数为n；
例如：num=12258的n=5,x1=1。

状态定义：设动态规划列表dp，dp[i]代表以xi为结尾的数字的翻译方案数量。
转移方程： 若xi和xi−1组成的两位数字可以被翻译，则dp[i]=dp[i−1]+dp[i−2]否则dp[i]=dp[i−1]。
可被翻译的两位数区间：当xi−1=0时，组成的两位数是无法被翻译的（例如00,01,02,⋯），因此区间为[10,25]。
初始状态：dp[0]=dp[1]=1，即"无数字"和"第1位数字"的翻译方法数量均为1；
返回值：dp[n]，即此数字的翻译方案数量。

Q：无数字情况dp[0]=1从何而来？
A：当num 第1,2位的组成的数字∈[10,25]时，显然应有2种翻译方法，即dp[2]=dp[1]+dp[0]=2，而显然dp[1]=1，因此推出dp[0]=1

方法一：字符串遍历 ../static/46.png
为方便获取数字的各位xi，考虑先将数字num转化为字符串s，通过遍历s实现动态规划。
通过字符串切片s[i−2:i]获取数字组合10xi−1+xi，通过对比字符串ASCII码判断字符串对应的数字区间。
空间使用优化：由于dp[i]只与dp[i−1]有关，因此可使用两个变量a,b分别记录dp[i],dp[i−1]，两变量交替前进即可。此方法可省去dp列表使用的O(N)的额外空间。

时间复杂度O(N) ： N为字符串s的长度（即数字num的位数log(num)），其决定了循环次数。
空间复杂度O(N) ： 字符串s使用O(N)大小的额外空间。
"""


class Solution:
    def translateNum(self, num):
        s = str(num)
        a = b = 1
        for i in range(2, len(s) + 1):
            a, b = (a + b if "10" <= s[i - 2:i] <= "25" else a), a
        return a


"""
方法二：数字求余
上述方法虽然已经节省了dp列表的空间占用，但字符串s仍使用了O(N)大小的额外空间。
空间复杂度优化：
利用求余运算num%10和求整运算num//10，可获取数字num的各位数字（获取顺序为个位、十位、百位…）。
因此，可通过"求余"和"求整"运算实现"从右向左"的遍历计算。而根据上述动态规划"对称性"，可知从右向左的计算是正确的。
自此，字符串s的空间占用也被省去，空间复杂度从O(N)降至O(1)。

时间复杂度O(N) ： N为字符串s的长度（即数字num的位数log(num)），其决定了循环次数。
空间复杂度O(1) ： 几个变量使用常数大小的额外空间。
"""


class Solution2:
    def translateNum(self, num):
        # 例：num = 122
        a = b = 1  # 代表"空数字"和"8"的翻译方案有1种
        y = num % 10  # 取余 获取个位数 12258%10=8
        while num != 0:
            num //= 10  # 取整  12258//10=1225
            x = num % 10  # 获取上一位数
            tmp = 10 * x + y  # 拼接数字
            c = a + b if 10 <= tmp <= 25 else a
            a, b = c, a
            y = x
        return a
