"""
在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

示例 1:
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物

动态规划
../static/47.png
题目说明：从棋盘的左上角开始拿格子里的礼物，并每次"向右"或者"向下"移动一格、直到到达棋盘的右下角。
根据题目说明，易得某单元格只可能从上边单元格或左边单元格到达。
设f(i,j)为从棋盘左上角走至单元格(i,j)的礼物最大累计价值，易得到以下递推关系：f(i,j)等于f(i,j−1)和f(i−1,j)中的较大值加上当前单元格礼物价值grid(i,j) 。
f(i,j)=max[f(i,j−1),f(i−1,j)]+grid(i,j)
因此，可用动态规划解决此问题，以上公式便为转移方程。

状态定义：设动态规划矩阵dp，dp(i,j)代表从棋盘的左上角开始，到达单元格(i,j)时能拿到礼物的最大累计价值。
转移方程：
1.当i=0且j=0时，为起始元素；  grid(i,j)
2.当i=0且j!=0时，为矩阵第一行元素，只可从左边到达；  grid(i,j)+dp(i,j−1)
3.当i!=0且j=0时，为矩阵第一列元素，只可从上边到达；  grid(i,j)+dp(i−1,j)
4.当i!=0且j!=0时，可从左边或上边到达；  grid(i,j)+max[dp(i−1,j),dp(i,j−1)]

初始状态：dp[0][0]=grid[0][0]，即到达单元格(0,0)时能拿到礼物的最大累计价值为grid[0][0]；
返回值：dp[m−1][n−1]，m,n分别为矩阵的行高和列宽，即返回dp矩阵右下角元素。

空间复杂度优化：
由于dp[i][j]只与dp[i−1][j],dp[i][j−1],grid[i][j]有关系，因此可以将原矩阵grid用作dp矩阵，即直接在grid上修改即可。
应用此方法可省去dp矩阵使用的额外空间，因此空间复杂度从O(MN)降至O(1)。

时间复杂度O(MN) ：M,N分别为矩阵行高、列宽；动态规划需遍历整个grid 矩阵，使用O(MN)时间。
空间复杂度O(1) ：原地修改使用常数大小的额外空间。
"""


class Solution:
    def maxValue(self, grid):
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == 0 and j == 0:
                    continue
                if i == 0:
                    grid[i][j] += grid[i][j - 1]
                elif j == 0:
                    grid[i][j] += grid[i - 1][j]
                else:
                    grid[i][j] += max(grid[i][j - 1], grid[i - 1][j])
        return grid[-1][-1]
